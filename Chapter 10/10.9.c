/* Напишите программу, которая инициализирует двумерный массив 3х5 значений
типа double и использует функцию, основанную на массивах переменной
длины, для копирования этого массива во второй двумерный массив. Кроме
того, напишите функцию, основанную на массивах переменной длины, для отображения
содержимого этих двух массивов. В общем случае обе функции должны
быть способны обрабатывать произвольные массивы NхМ. (Если вы не имеете
доступа к компилятору, подлерживающему массивы переменной длины, примените
традиционный подход С с функциями, которые могут обрабатывать массивы
Nx5). */
#include <stdio.h>
#include <stdlib.h>
void mas_v(int n, int m, double mas[n][m]); // Объявление функции отображения массива
void copy_arr(int x, int y, double copy[x][y], double origin[x][y]); // Объявление функции копирования двумерных массивов
int main()
{
    double source[3][5] = {{0.1,0.2,0.3,0.4,0.5},
                           {1.1,1.2,1.3,1.4,1.5},
                           {3.1,3.2,3.3,3.4,3.5}};
    double copy[3][5];
    printf("Source = {");
    mas_v(3, 5, source);
    printf("Before copy = {");
    mas_v(3, 5, copy);
    copy_arr(3, 5, copy, source);
    printf("After copy = {");
    mas_v(3, 5, copy);
    return 0;
}
/* Отображение массива производится в виде матрицы элементов, на мой взгляд вполне наглядно
   Хоть и по наличию фигурных скобок не очень правильно. */
void mas_v(int n, int m, double mas[n][m]) // Отображение массива
{
    for(int x_count = 0; x_count < n; x_count++) // Циклы для отображения двумерных массивов
    {
        printf("\n");
         for(int y_count = 0; y_count < m; y_count++)
            printf(" %1.1f ", mas[x_count][y_count]);
    }
    printf("};\n");
}
void copy_arr(int x, int y, double copy[x][y], double origin[x][y]) // Копирование массива
{

    for(int count_x = 0; count_x < x; count_x++) // Цикл поэлементного копирования
    {
        for(int count_y = 0; count_y < y; count_y++)
            copy[count_x][count_y] = origin[count_x][count_y];
    }
    return;
}
